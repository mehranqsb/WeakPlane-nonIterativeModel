/**
 * \file
 * \copyright
 * Copyright (c) 2012-2024, OpenGeoSys Community (http://www.opengeosys.org)
 *            Distributed under a Modified BSD License.
 *              See accompanying file LICENSE.txt or
 *              http://www.opengeosys.org/project/license
 */

@Author Thomas Nagel;
@Date 20 / 07 / 2024;
@Description{
    Implementation of non - associated flow rule of the Brown yield criterion,
    which is derived based on the work of Hoek and Brown,
    https : // doi.org/10.1016/j.jrmge.2018.08.001.
            Adding three arbitrarily oriented joint sets and elastic
                orthotropy.All plastic models are non -
        associated.
};

@DSL DefaultDSL;
@Behaviour WeakPlaneModelNonIter;
@MaterialProperty real young;
young.setEntryName("Em");
@MaterialProperty real nu;
nu.setEntryName("nu");
// weakness plane cohesion
@MaterialProperty real c_wp;
c_wp.setEntryName("PlaneCohesion");
// weakness plane friction angle
@MaterialProperty real phi_wp;
phi_wp.setEntryName("PlaneFrictionAngle");
// weakness plane dilatancy angle
@MaterialProperty real psi_wp;
psi_wp.setEntryName("PlaneDilatancyAngle");
// set of normal vectors
@MaterialProperty real normals[3];
normals.setEntryName("Normals");

@StateVariable StrainStensor eel;
eel.setGlossaryName("ElasticStrain");
@StateVariable strain p;
p.setEntryName("EquivalentPlasticStrainWP");
@AuxiliaryStateVariable strain p_prev;
p_prev.setGlossaryName("EquivalentPlasticStrain");

@Parameter local_zero_tolerance = 1.e-14;
@Parameter pi = 3.141592653589793;

// Local variable
@LocalVariable bool plastic_loadingWP;
@LocalVariable real tan_phi_wp;
@LocalVariable real tan_psi_wp;
@LocalVariable real tractions[3];
@LocalVariable real slips[3];
@LocalVariable real normal_stresses;
@LocalVariable real shear_stresses;
@LocalVariable StressStensor sig0;

@PredictionOperator
{
    const auto lambda = computeLambda(young, nu);
    const auto mu = computeMu(young, nu);
    Dt = lambda * Stensor4::IxI() + 2 * mu * Stensor4::Id();
}

@Private
{
    real yieldFunctionWP()
    {
        // Compute the yield function for the specified component.
        // Assuming s[0], s[1], and s[2] correspond to normal stresses on the
        // weak planes, and adjusting the indices accordingly based on your
        // actual stress tensor layout.
        return shear_stresses - c_wp + normal_stresses * tan_phi_wp;
    }

    void calculate_tractions(const Stensor &s)
    {
        constexpr auto sqrt2 = math::Cste<real>::sqrt2;
        // Calculate tractions for 3D and 2D cases
        if (eel.size() == 6)
        {
            tractions[0] = s[0] * normals[0] + s[3] / sqrt2 * normals[1] +
                           s[4] / sqrt2 * normals[2];
            tractions[1] = s[3] / sqrt2 * normals[0] + s[1] * normals[1] +
                           s[5] / sqrt2 * normals[2];
            tractions[2] = s[4] / sqrt2 * normals[0] +
                           s[5] / sqrt2 * normals[1] + s[2] * normals[2];
        }
        else
        {
            tractions[0] = s[0] * normals[0] + s[3] / sqrt2 * normals[1];
            tractions[1] = s[3] / sqrt2 * normals[0] + s[1] * normals[1];
            tractions[2] = s[2] * normals[2];
        }
        // normal stresses
        normal_stresses = 0;
        for (int i = 0; i < 3; ++i)
            normal_stresses += tractions[i] * normals[i];

        // shear stresses and slip directions
        for (int i = 0; i < 3; ++i)
            slips[i] = tractions[i] - normal_stresses * normals[i];

        shear_stresses = 0;
        for (int i = 0; i < 3; ++i)
            shear_stresses += slips[i] * slips[i];
        shear_stresses = std::sqrt(shear_stresses);

        for (int i = 0; i < 3; ++i)
        {
            std::cout << "PL= " << shear_stresses << std::endl;     
            if (shear_stresses > local_zero_tolerance * Dt(0, 0))
                slips[i] = slips[i] / shear_stresses;
            else
                slips[i] = normals[i]; // no slip should occur in this case;
                                       // keeping values well defined.
        }
        return;
    }

    Stensor a_otimes_b(const real avec[3], const real bvec[3], const int dim)
    {
        auto a_ot_b = Stensor::Id();
        constexpr auto sqrt2 = math::Cste<real>::sqrt2;

        for (int i = 0; i < 3; ++i)
            a_ot_b[i] = avec[i] * bvec[i];
        a_ot_b[3] = (avec[0] * bvec[1] + avec[1] * bvec[0]) / sqrt2;
        if (dim == 6)
        {
            a_ot_b[4] = (avec[0] * bvec[2] + avec[2] * bvec[0]) / sqrt2;
            a_ot_b[5] = (avec[1] * bvec[2] + avec[2] * bvec[1]) / sqrt2;
        }
        return a_ot_b;
    }
}

@InitLocalVariables
{
    tan_phi_wp = std::tan(phi_wp * pi / 180);
    tan_psi_wp = std::tan(psi_wp * pi / 180);
    sig0 = sig;
    plastic_loadingWP = yieldFunctionWP() > 0.;
}

@ProvidesSymmetricTangentOperator;
@Integrator
{
    constexpr auto id = Stensor::Id();
    constexpr auto id4 = Stensor4::Id();
    const auto lambda = computeLambda(young, nu);
    const auto mu = computeMu(young, nu);

    eel += deto;
    if (computeTangentOperator_)
    {
        Dt = lambda * Stensor4::IxI() + 2 * mu * id4;
    }
    const auto Dt_el = lambda * Stensor4::IxI() + 2 * mu * id4;
    const auto sig_el = sig0 + Dt * deto;
    calculate_tractions(sig_el);

    if (plastic_loadingWP)
    {

        // flow direction and yield function gradient
        auto n = id;
        const Stensor n_otimes_n =
            a_otimes_b(&normals[0], &normals[0], sig.size());
        const Stensor n_otimes_m =
            a_otimes_b(&normals[0], &slips[0], sig.size());

        n = tan_psi_wp * n_otimes_n + n_otimes_m;

        auto nF = id;
        nF = tan_phi_wp * n_otimes_n + n_otimes_m;
        const auto Dt_p =
            (n | Dt_el) ^ (nF | Dt_el) / (((nF | Dt_el) | n));
        // std::cout << "PEEQ " << p  << std::endl;
        dp = ((nF | Dt_el) | deto) / (((nF | Dt_el) | n));
        eel -= dp * n;
        if ((computeTangentOperator_) && (smt == CONSISTENTTANGENTOPERATOR))
        {    
            Dt -= Dt_p;
        }
    }
    // stress update
    sig = sig0 + Dt * deto;
    dp = std::max(dp, 0.0);
}
@UpdateAuxiliaryStateVariables
{
    p_prev = std::max(p, 0.0) - dp;
}
